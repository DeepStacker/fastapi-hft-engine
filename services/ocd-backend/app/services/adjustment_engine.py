"""
Adjustment Engine Service

Monitors tracked positions and suggests adjustments based on:
- Delta drift from entry
- IV changes (crush or spike)
- Tested legs (approaching breakeven)
- Time decay acceleration
- Profit target / stop loss conditions

Generates alerts and adjustment recommendations.
"""
import logging
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict
from enum import Enum

from app.services.strategy_simulation_service import StrategySimulationService, StrategyLeg
from app.services.bsm import BSMService

logger = logging.getLogger(__name__)


# ============================================================
# CONFIGURATION
# ============================================================

class AlertSeverity(str, Enum):
    INFO = "info"
    WARNING = "warning"
    CRITICAL = "critical"


class AlertType(str, Enum):
    DELTA_DRIFT = "delta_drift"
    GAMMA_RISK = "gamma_risk"
    THETA_DECAY = "theta_decay"
    IV_SPIKE = "iv_spike"
    IV_CRUSH = "iv_crush"
    LEG_TESTED = "leg_tested"
    PROFIT_TARGET = "profit_target"
    STOP_LOSS = "stop_loss"
    TIME_WARNING = "time_warning"
    ADJUSTMENT_SUGGESTED = "adjustment_suggested"


@dataclass
class AdjustmentConfig:
    """Configuration for adjustment triggers."""
    # Delta thresholds
    delta_drift_warning: float = 0.10  # Warn if net delta drifts by 0.10
    delta_drift_critical: float = 0.20  # Critical if drifts by 0.20
    
    # IV thresholds
    iv_spike_warning: float = 0.15  # 15% increase from entry
    iv_spike_critical: float = 0.30  # 30% increase
    iv_crush_warning: float = 0.15  # 15% decrease
    
    # Leg tested thresholds
    leg_test_buffer: float = 0.02  # 2% buffer before leg is "tested"
    
    # P&L thresholds (as % of max profit)
    profit_target: float = 0.50  # Take profit at 50% of max profit
    stop_loss: float = 1.50  # Stop at 150% of max profit (credit) or 100% of premium (debit)
    
    # Time thresholds
    time_warning_dte: int = 7  # Warn when 7 DTE
    time_critical_dte: int = 3  # Critical at 3 DTE
    
    # Gamma acceleration
    gamma_risk_threshold: float = 0.10  # Daily gamma risk as % of position


@dataclass
class PositionAlert:
    """Alert generated by the adjustment engine."""
    alert_type: str
    severity: str
    message: str
    current_value: float
    threshold_value: float
    recommended_action: Optional[str] = None
    suggested_adjustment: Optional[Dict[str, Any]] = None
    detected_at: str = None
    
    def __post_init__(self):
        if self.detected_at is None:
            self.detected_at = datetime.now().isoformat()
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


@dataclass
class AdjustmentSuggestion:
    """A suggested adjustment to a position."""
    adjustment_type: str  # roll_up, roll_down, roll_out, add_hedge, close
    trigger_reason: str
    
    # What to close
    close_legs: List[Dict[str, Any]]
    
    # What to open
    open_legs: List[Dict[str, Any]]
    
    # Estimated impact
    estimated_cost: float  # Negative = credit
    new_max_profit: float
    new_max_loss: float
    new_breakevens: List[float]
    new_pop: float
    
    confidence: float = 0.5
    
    def to_dict(self) -> Dict[str, Any]:
        return asdict(self)


# ============================================================
# ADJUSTMENT ENGINE
# ============================================================

class AdjustmentEngine:
    """
    Monitors positions and generates adjustment recommendations.
    
    Core responsibilities:
    1. Analyze current position Greeks vs entry
    2. Detect risk conditions (tested legs, gamma risk)
    3. Generate alerts with appropriate severity
    4. Suggest specific adjustments to restore risk profile
    """
    
    def __init__(
        self,
        config: Optional[AdjustmentConfig] = None,
        simulation_service: Optional[StrategySimulationService] = None
    ):
        self.config = config or AdjustmentConfig()
        self.sim = simulation_service or StrategySimulationService()
        self.bsm = BSMService()
    
    # --------------------------------------------------------
    # PUBLIC API
    # --------------------------------------------------------
    
    def analyze_position(
        self,
        position: Dict[str, Any],
        current_spot: float,
        current_iv: float,
        current_date: Optional[datetime] = None,
        option_chain: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """
        Analyze a tracked position and generate alerts/suggestions.
        
        Args:
            position: Tracked position dict with legs, entry_metrics, etc.
            current_spot: Current spot price
            current_iv: Current ATM IV
            current_date: Current date (defaults to now)
        
        Returns:
            {
                "alerts": List[PositionAlert],
                "adjustments": List[AdjustmentSuggestion],
                "current_metrics": {...},
                "risk_score": float  # 0-100
            }
        """
        current_date = current_date or datetime.now()
        alerts = []
        adjustments = []
        
        # Extract position data
        legs = position.get("legs", [])
        entry_metrics = position.get("entry_metrics") or {}
        entry_spot = position.get("entry_spot", current_spot)
        entry_iv = position.get("entry_atm_iv", current_iv)
        expiry_str = position.get("expiry", "")
        
        if not legs:
            return {
                "alerts": [],
                "adjustments": [],
                "current_metrics": {},
                "risk_score": 0
            }
        
        # Calculate current metrics
        current_metrics = self._calculate_current_metrics(
            legs, current_spot, current_iv, expiry_str, current_date
        )
        
        # Calculate DTE
        dte = self._calculate_dte(expiry_str, current_date)
        current_metrics["dte"] = dte
        
        # Run all checks
        alerts.extend(self._check_delta_drift(entry_metrics, current_metrics))
        alerts.extend(self._check_iv_change(entry_iv, current_iv))
        alerts.extend(self._check_leg_tested(legs, current_spot, entry_spot))
        alerts.extend(self._check_pnl_targets(position, current_metrics))
        alerts.extend(self._check_time_decay(dte))
        alerts.extend(self._check_gamma_risk(current_metrics, dte))
        
        # Generate adjustment suggestions for critical alerts
        critical_alerts = [a for a in alerts if a.severity == AlertSeverity.CRITICAL.value]
        if critical_alerts and option_chain:
            adjustments = self._generate_adjustments(
                position, current_spot, current_iv, expiry_str, critical_alerts, option_chain
            )
        
        # Calculate overall risk score
        risk_score = self._calculate_risk_score(alerts, current_metrics, dte)
        
        return {
            "alerts": [a.to_dict() for a in alerts],
            "adjustments": [a.to_dict() for a in adjustments],
            "current_metrics": current_metrics,
            "risk_score": risk_score
        }
    
    def suggest_roll(
        self,
        position: Dict[str, Any],
        roll_type: str,  # "up", "down", "out"
        current_spot: float,
        current_iv: float,
        option_chain: Dict[str, Any],
        step_size: float = 50
    ) -> Optional[AdjustmentSuggestion]:
        """
        Generate a specific roll suggestion.
        
        Roll types:
        - up: Move short strikes higher (bullish adjustment)
        - down: Move short strikes lower (bearish adjustment)
        - out: Extend to next expiry
        """
        legs = position.get("legs", [])
        if not legs:
            return None
        
        # Identify short legs to roll
        short_legs = [l for l in legs if l.get("action") == "SELL"]
        if not short_legs:
            return None
        
        close_legs = []
        open_legs = []
        
        for leg in short_legs:
            original_strike = leg.get("strike")
            option_type = leg.get("option_type")
            qty = leg.get("qty", 1)
            lot_size = leg.get("lot_size", 1)
            
            # Determine new strike
            if roll_type == "up":
                new_strike = original_strike + step_size
            elif roll_type == "down":
                new_strike = original_strike - step_size
            else:  # out - same strike, different expiry
                new_strike = original_strike
            
            # Get current premium for closing
            old_opt_data = self._find_option_in_dict(
                option_chain, original_strike, option_type
            )
            new_opt_data = self._find_option_in_dict(
                option_chain, new_strike, option_type
            )
            
            if not old_opt_data or not new_opt_data:
                continue
            
            # Close the existing short
            close_legs.append({
                "strike": original_strike,
                "option_type": option_type,
                "action": "BUY",  # Buy to close
                "qty": qty,
                "lot_size": lot_size,
                "ltp": old_opt_data.get("ltp", 0)
            })
            
            # Open new short
            open_legs.append({
                "strike": new_strike,
                "option_type": option_type,
                "action": "SELL",  # Sell to open
                "qty": qty,
                "lot_size": lot_size,
                "ltp": new_opt_data.get("ltp", 0)
            })
        
        if not close_legs or not open_legs:
            return None
        
        # Calculate adjustment cost
        close_cost = sum(l["ltp"] * l["qty"] * l["lot_size"] for l in close_legs)  # Debit
        open_credit = sum(l["ltp"] * l["qty"] * l["lot_size"] for l in open_legs)  # Credit
        net_cost = close_cost - open_credit  # Positive = debit
        
        return AdjustmentSuggestion(
            adjustment_type=f"roll_{roll_type}",
            trigger_reason=f"Manual roll {roll_type} requested",
            close_legs=close_legs,
            open_legs=open_legs,
            estimated_cost=net_cost,
            new_max_profit=0,  # Would need full simulation
            new_max_loss=0,
            new_breakevens=[],
            new_pop=0,
            confidence=0.6
        )
    
    # --------------------------------------------------------
    # PRIVATE: CHECKS
    # --------------------------------------------------------
    
    def _check_delta_drift(
        self,
        entry_metrics: Dict[str, Any],
        current_metrics: Dict[str, Any]
    ) -> List[PositionAlert]:
        """Check if position delta has drifted significantly from entry."""
        alerts = []
        
        # Handle None metrics
        if not entry_metrics or not current_metrics:
            return alerts
        
        entry_delta = entry_metrics.get("net_delta", 0)
        current_delta = current_metrics.get("net_delta", 0)
        drift = abs(current_delta - entry_delta)
        
        if drift >= self.config.delta_drift_critical:
            alerts.append(PositionAlert(
                alert_type=AlertType.DELTA_DRIFT.value,
                severity=AlertSeverity.CRITICAL.value,
                message=f"Net delta has drifted {drift:.2f} from entry ({entry_delta:.2f} → {current_delta:.2f})",
                current_value=drift,
                threshold_value=self.config.delta_drift_critical,
                recommended_action="Consider rolling untested side to restore delta neutrality"
            ))
        elif drift >= self.config.delta_drift_warning:
            alerts.append(PositionAlert(
                alert_type=AlertType.DELTA_DRIFT.value,
                severity=AlertSeverity.WARNING.value,
                message=f"Net delta drifting: {entry_delta:.2f} → {current_delta:.2f}",
                current_value=drift,
                threshold_value=self.config.delta_drift_warning
            ))
        
        return alerts
    
    def _check_iv_change(
        self,
        entry_iv: float,
        current_iv: float
    ) -> List[PositionAlert]:
        """Check for significant IV changes."""
        alerts = []
        
        if entry_iv <= 0:
            return alerts
        
        iv_change = (current_iv - entry_iv) / entry_iv
        
        if iv_change >= self.config.iv_spike_critical:
            alerts.append(PositionAlert(
                alert_type=AlertType.IV_SPIKE.value,
                severity=AlertSeverity.CRITICAL.value,
                message=f"IV spiked {iv_change*100:.1f}% ({entry_iv:.1f}% → {current_iv:.1f}%)",
                current_value=iv_change,
                threshold_value=self.config.iv_spike_critical,
                recommended_action="Consider closing position or adding hedge"
            ))
        elif iv_change >= self.config.iv_spike_warning:
            alerts.append(PositionAlert(
                alert_type=AlertType.IV_SPIKE.value,
                severity=AlertSeverity.WARNING.value,
                message=f"IV increased {iv_change*100:.1f}%",
                current_value=iv_change,
                threshold_value=self.config.iv_spike_warning
            ))
        elif iv_change <= -self.config.iv_crush_warning:
            alerts.append(PositionAlert(
                alert_type=AlertType.IV_CRUSH.value,
                severity=AlertSeverity.INFO.value,
                message=f"IV crushed {abs(iv_change)*100:.1f}% - favorable for short premium",
                current_value=abs(iv_change),
                threshold_value=self.config.iv_crush_warning
            ))
        
        return alerts
    
    def _check_leg_tested(
        self,
        legs: List[Dict[str, Any]],
        current_spot: float,
        entry_spot: float
    ) -> List[PositionAlert]:
        """Check if any short leg is being tested (spot approaching strike)."""
        alerts = []
        
        for leg in legs:
            if leg.get("action") != "SELL":
                continue
            
            strike = leg.get("strike", 0)
            option_type = leg.get("option_type")
            
            # Calculate distance
            distance = abs(current_spot - strike) / current_spot
            
            if distance <= self.config.leg_test_buffer:
                direction = "above" if current_spot > strike else "below"
                alerts.append(PositionAlert(
                    alert_type=AlertType.LEG_TESTED.value,
                    severity=AlertSeverity.CRITICAL.value,
                    message=f"Short {strike} {option_type} is being tested (spot {direction} at {distance*100:.1f}%)",
                    current_value=distance,
                    threshold_value=self.config.leg_test_buffer,
                    recommended_action=f"Consider rolling the tested leg or closing position"
                ))
        
        return alerts
    
    def _check_pnl_targets(
        self,
        position: Dict[str, Any],
        current_metrics: Dict[str, Any]
    ) -> List[PositionAlert]:
        """Check if P&L targets are hit."""
        alerts = []
        
        entry_metrics = position.get("entry_metrics", {})
        if not entry_metrics:
            return alerts
        
        max_profit = entry_metrics.get("max_profit", 0)
        max_loss = entry_metrics.get("max_loss", 0)
        current_pnl = position.get("current_pnl", 0)
        
        if max_profit <= 0:
            return alerts
        
        # Check profit target
        pnl_vs_max = current_pnl / max_profit if max_profit else 0
        
        if pnl_vs_max >= self.config.profit_target:
            alerts.append(PositionAlert(
                alert_type=AlertType.PROFIT_TARGET.value,
                severity=AlertSeverity.INFO.value,
                message=f"Position at {pnl_vs_max*100:.0f}% of max profit (₹{current_pnl:.0f})",
                current_value=pnl_vs_max,
                threshold_value=self.config.profit_target,
                recommended_action="Consider taking profits"
            ))
        
        # Check stop loss
        if max_loss > 0:
            loss_ratio = abs(current_pnl) / max_loss if current_pnl < 0 else 0
            if loss_ratio >= self.config.stop_loss:
                alerts.append(PositionAlert(
                    alert_type=AlertType.STOP_LOSS.value,
                    severity=AlertSeverity.CRITICAL.value,
                    message=f"Position loss exceeds threshold (₹{abs(current_pnl):.0f} = {loss_ratio*100:.0f}% of max loss)",
                    current_value=loss_ratio,
                    threshold_value=self.config.stop_loss,
                    recommended_action="Consider closing position to limit further losses"
                ))
        
        return alerts
    
    def _check_time_decay(self, dte: int) -> List[PositionAlert]:
        """Check days to expiry and gamma acceleration."""
        alerts = []
        
        if dte <= self.config.time_critical_dte:
            alerts.append(PositionAlert(
                alert_type=AlertType.TIME_WARNING.value,
                severity=AlertSeverity.CRITICAL.value,
                message=f"Only {dte} DTE remaining - gamma risk elevated",
                current_value=dte,
                threshold_value=self.config.time_critical_dte,
                recommended_action="Consider closing or rolling out to next expiry"
            ))
        elif dte <= self.config.time_warning_dte:
            alerts.append(PositionAlert(
                alert_type=AlertType.TIME_WARNING.value,
                severity=AlertSeverity.WARNING.value,
                message=f"{dte} DTE remaining - monitor closely",
                current_value=dte,
                threshold_value=self.config.time_warning_dte
            ))
        
        return alerts
    
    def _check_gamma_risk(
        self,
        current_metrics: Dict[str, Any],
        dte: int
    ) -> List[PositionAlert]:
        """Check if gamma risk is too high for remaining time."""
        alerts = []
        
        if not current_metrics:
            return alerts
        
        net_gamma = abs(current_metrics.get("net_gamma", 0))
        # Simplified gamma risk: gamma * 1% move * days remaining
        if dte > 0:
            gamma_impact = net_gamma * 0.01 * dte
            if gamma_impact > self.config.gamma_risk_threshold:
                alerts.append(PositionAlert(
                    alert_type=AlertType.GAMMA_RISK.value,
                    severity=AlertSeverity.WARNING.value,
                    message=f"Elevated gamma risk: {gamma_impact:.2%} potential delta swing",
                    current_value=gamma_impact,
                    threshold_value=self.config.gamma_risk_threshold
                ))
        
        return alerts
    
    # --------------------------------------------------------
    # PRIVATE: HELPERS
    # --------------------------------------------------------
    
    def _calculate_current_metrics(
        self,
        legs: List[Dict[str, Any]],
        current_spot: float,
        current_iv: float,
        expiry_str: str,
        current_date: datetime
    ) -> Dict[str, Any]:
        """Calculate current position metrics."""
        # Convert legs to simulation format
        sim_legs = []
        for leg in legs:
            sim_legs.append(StrategyLeg(
                strike=leg.get("strike", 0),
                option_type=leg.get("option_type", "CE"),
                action=leg.get("action", "BUY"),
                qty=leg.get("qty", 1),
                entry_price=leg.get("entry_price", 0),
                iv=current_iv / 100 if current_iv > 1 else current_iv,
                expiry=expiry_str,
                lot_size=leg.get("lot_size", 1)
            ))
        
        try:
            # Use simulation service
            # For current metrics, we might want to enforce a minimum time if 0 DTE to get Greeks
            # But the simulation service should handle it. 
            # If dte=0, let's pass a small positive iv_change or just ensure dates match.
            
            result = self.sim.simulate_strategy_at_point(
                legs=sim_legs,
                spot_price=current_spot,
                simulation_date=current_date,
                iv_change=0
            )
            return {
                "pnl": result.pnl,
                "net_delta": result.net_delta,
                "net_gamma": result.net_gamma,
                "net_theta": result.net_theta,
                "net_vega": result.net_vega
            }
        except Exception as e:
            logger.warning(f"Failed to calculate metrics: {e}")
            return {}
    
    def _calculate_dte(self, expiry_str: str, current_date: datetime) -> int:
        """Calculate days to expiry (safe)."""
        try:
            # Handle various date formats
            for fmt in ["%d-%m-%Y", "%d-%b-%Y", "%Y-%m-%d"]:
                try:
                    expiry_date = datetime.strptime(expiry_str, fmt)
                    # Convert both to date objects for day diff
                    diff = (expiry_date.date() - current_date.date()).days
                    return max(0, diff)
                except ValueError:
                    continue
            return 0
        except Exception:
            return 0
    
    def _calculate_risk_score(
        self,
        alerts: List[PositionAlert],
        current_metrics: Dict[str, Any],
        dte: int
    ) -> float:
        """Calculate overall risk score (0-100)."""
        score = 0
        
        # Base score from alerts
        for alert in alerts:
            if alert.severity == AlertSeverity.CRITICAL.value:
                score += 30
            elif alert.severity == AlertSeverity.WARNING.value:
                score += 15
            else:
                score += 5
        
        # DTE contribution
        if dte <= 3:
            score += 20
        elif dte <= 7:
            score += 10
        
        # Cap at 100
        return min(100, score)
    
    def _generate_adjustments(
        self,
        position: Dict[str, Any],
        current_spot: float,
        current_iv: float,
        expiry_str: str,
        critical_alerts: List[PositionAlert],
        option_chain: Dict[str, Any]
    ) -> List[AdjustmentSuggestion]:
        """Generate adjustment suggestions for critical conditions."""
        suggestions = []
        
        for alert in critical_alerts:
            if alert.alert_type == AlertType.LEG_TESTED.value:
                # Suggest roll away from spot
                direction = "up" if "PE" in alert.message else "down"
                
                suggestion = self.suggest_roll(
                    position, direction, current_spot, current_iv, option_chain
                )
                
                if suggestion:
                    suggestion.trigger_reason = alert.message
                    suggestions.append(suggestion)
            
            elif alert.alert_type == AlertType.TIME_WARNING.value:
                suggestions.append(AdjustmentSuggestion(
                    adjustment_type="roll_out",
                    trigger_reason=alert.message,
                    close_legs=[],
                    open_legs=[],
                    estimated_cost=0,
                    new_max_profit=0,
                    new_max_loss=0,
                    new_breakevens=[],
                    new_pop=0,
                    confidence=0.6
                ))
            
            elif alert.alert_type == AlertType.STOP_LOSS.value:
                suggestions.append(AdjustmentSuggestion(
                    adjustment_type="close_full",
                    trigger_reason=alert.message,
                    close_legs=position.get("legs", []),
                    open_legs=[],
                    estimated_cost=0,
                    new_max_profit=0,
                    new_max_loss=0,
                    new_breakevens=[],
                    new_pop=0,
                    confidence=0.8
                ))
        
        return suggestions
    
    def _find_option_in_dict(
        self,
        chain: Dict[str, Any],
        strike: float,
        option_type: str
    ) -> Optional[Dict[str, Any]]:
        """Find option in processed dict chain."""
        try:
            strike_data = chain.get(str(strike))
            if not strike_data:
                # Try finding closest strike if exact not found
                # (Optional optimization: implement if needed)
                return None
            
            leg_data = strike_data.get(option_type.lower())
            if not leg_data:
                return None
                
            return leg_data
        except Exception:
            return None
        """Find option data in chain."""
        for opt in chain:
            if abs(opt.get("strike", 0) - strike) < 1 and opt.get("option_type") == option_type:
                return opt
        return None


# ============================================================
# FACTORY
# ============================================================

_adjustment_engine_instance = None

def get_adjustment_engine() -> AdjustmentEngine:
    """Get singleton instance of AdjustmentEngine."""
    global _adjustment_engine_instance
    if _adjustment_engine_instance is None:
        _adjustment_engine_instance = AdjustmentEngine()
    return _adjustment_engine_instance
